<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kaitlyn & Angel: Valentine</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0b0f19; overflow:hidden; }
    canvas { display:block; margin:0 auto; image-rendering: pixelated; image-rendering: crisp-edges; }

    #hud {
      position: fixed; left: 14px; bottom: 14px;
      font-family: system-ui, Arial; font-size: 14px; color: rgba(255,255,255,0.85);
      background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.12);
      padding: 10px 12px; border-radius: 12px;
      backdrop-filter: blur(6px);
      max-width: 380px;
      user-select: none;
    }
    #hud b { color:#fff; }
    #status { opacity: 0.95; }

    /* Dialogue UI */
    #dialogueUI {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 18px; width: min(860px, calc(100vw - 28px));
      display: none;
      font-family: system-ui, Arial;
      user-select: none;
    }
    #choices {
      display:flex; gap: 12px; justify-content:center; align-items:center;
      padding: 10px;
      background: rgba(0,0,0,0.40);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      backdrop-filter: blur(8px);
    }
    .choiceBtn {
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.10);
      color: white;
      border-radius: 12px;
      padding: 10px 16px;
      cursor: pointer;
      font-weight: 700;
      transition: transform 120ms ease, filter 120ms ease, padding 120ms ease, font-size 120ms ease;
    }
    .choiceBtn:hover { filter: brightness(1.12); transform: translateY(-1px); }
    #midMsg {
      color: rgba(255,255,255,0.9);
      font-weight: 700;
      padding: 6px 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      display:none;
      white-space: nowrap;
    }

    /* End screen overlay */
    #endOverlay {
      position: fixed; inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.75);
      color: white;
      font-family: system-ui, Arial;
      font-size: clamp(36px, 6vw, 96px);
      font-weight: 900;
      letter-spacing: 2px;
      user-select: none;
    }
  </style>
</head>
<body>
  <canvas id="game" width="960" height="540"></canvas>

  <div id="hud">
    <b>Controls</b><br>
    Right-click: move (click-to-move)<br>
    Left-click: interact (when something glows)<br>
    <span id="status"></span>
  </div>

  <div id="dialogueUI">
    <div id="choices">
      <button id="yesBtn" class="choiceBtn">YES</button>
      <div id="midMsg">try again.</div>
      <button id="noBtn" class="choiceBtn">NO</button>
    </div>
  </div>

  <div id="endOverlay">The End</div>

<script>
(() => {
  // ---------- Canvas / scaling ----------
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const statusEl = document.getElementById("status");
  const dialogueUI = document.getElementById("dialogueUI");
  const yesBtn = document.getElementById("yesBtn");
  const noBtn = document.getElementById("noBtn");
  const midMsg = document.getElementById("midMsg");
  const endOverlay = document.getElementById("endOverlay");

  // Internal resolution for pixel vibe
  const W = 320, H = 180;

  const off = document.createElement("canvas");
  off.width = W; off.height = H;
  const octx = off.getContext("2d");

  function resize() {
    const aspect = canvas.width / canvas.height;
    const ww = window.innerWidth, wh = window.innerHeight;
    let w = ww, h = ww / aspect;
    if (h > wh) { h = wh; w = wh * aspect; }
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
  }
  window.addEventListener("resize", resize);
  resize();

  window.addEventListener("contextmenu", (e) => e.preventDefault());

  // ---------- Helpers ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist = (ax, ay, bx, by) => Math.hypot(ax - bx, ay - by);

  function screenToWorld(e) {
    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left) / rect.width;
    const sy = (e.clientY - rect.top) / rect.height;
    return { x: sx * W, y: sy * H };
  }

  function rectsOverlap(a, b) {
    return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
  }

  // ---------- Camera ----------
  const camera = { x: 0, y: 0 };
  function follow(target) {
    camera.x = target.x + target.w/2 - W/2;
    camera.y = target.y + target.h/2 - H/2;
  }

  // ---------- Player + sprites ----------
  function makePlayer() {
    return {
      name: "Kaitlyn",
      x: 0, y: 0,
      w: 10, h: 12,
      speed: 55,
      target: null,
      moving: false,
      canControl: false,
      facing: "down",
      intro: { active: true, t: 0, phase: 0 },
      pose: "stand", // stand | sit | hug
    };
  }

  function drawKaitlyn(ctx, p, pose = "stand") {
    const hair = "#d8b15e";
    const hair2 = "#b78b3d";
    const skin = "#f3caa5";
    const dress = "#f2e8f5";
    const outline = "rgba(0,0,0,0.35)";

    ctx.save();
    ctx.translate(Math.round(p.x), Math.round(p.y));

    // Shadow
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(p.w/2, p.h+2, p.w/2+1, 2, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    const sitting = pose === "sit" || pose === "hug";
    const bodyY = sitting ? 7 : 6;
    const headY = sitting ? 2 : 1;

    // Legs
    ctx.fillStyle = "#caa6a6";
    if (!sitting) {
      ctx.fillRect(2, p.h-2, 2, 2);
      ctx.fillRect(p.w-4, p.h-2, 2, 2);
    } else {
      // tucked legs
      ctx.fillRect(3, p.h-3, 4, 2);
    }

    // Dress/torso
    ctx.fillStyle = dress;
    ctx.fillRect(1, bodyY, p.w-2, sitting ? 5 : 6);

    // Head
    ctx.fillStyle = skin;
    ctx.fillRect(2, headY, p.w-4, 6);

    // Hair
    ctx.fillStyle = hair;
    ctx.fillRect(1, headY-1, p.w-2, 3);
    ctx.fillRect(1, headY, 2, 6);
    ctx.fillRect(p.w-3, headY, 2, 6);

    ctx.fillStyle = hair2;
    ctx.fillRect(2, headY-1, p.w-4, 1);
    ctx.fillRect(1, headY+1, 1, 4);
    ctx.fillRect(p.w-2, headY+1, 1, 4);

    // Eyes
    ctx.fillStyle = "#1a1a1a";
    ctx.fillRect(4, headY+2, 1, 1);
    ctx.fillRect(p.w-5, headY+2, 1, 1);

    // Hug arms (simple overlay)
    if (pose === "hug") {
      ctx.fillStyle = "rgba(0,0,0,0.12)";
      ctx.fillRect(2, bodyY+2, p.w-4, 2);
    }

    // Outline
    ctx.strokeStyle = outline;
    ctx.strokeRect(1, headY, p.w-2, p.h-1);

    ctx.restore();
  }

  function drawAngel(ctx, a, pose = "sit", glow = 0) {
    const hair = "#1a1a1a";
    const hair2 = "#333";
    const skin = "#e9c3a0";
    const hoodie = "#f3f3f3";
    const outline = "rgba(0,0,0,0.35)";

    ctx.save();
    ctx.translate(Math.round(a.x), Math.round(a.y));

    // Glow aura
    if (glow > 0.01) {
      ctx.globalAlpha = 0.25 * glow;
      ctx.fillStyle = "#ffd36a";
      ctx.fillRect(-6, -6, a.w + 12, a.h + 12);
      ctx.globalAlpha = 1;
    }

    // Shadow
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(a.w/2, a.h+2, a.w/2+1, 2, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    const sitting = pose === "sit" || pose === "hug";
    const bodyY = sitting ? 7 : 6;
    const headY = sitting ? 2 : 1;

    // Hoodie body
    ctx.fillStyle = hoodie;
    ctx.fillRect(1, bodyY, a.w-2, sitting ? 5 : 6);

    // Head
    ctx.fillStyle = skin;
    ctx.fillRect(2, headY, a.w-4, 6);

    // Curly hair
    ctx.fillStyle = hair;
    for (let i = 1; i < a.w-1; i += 2) ctx.fillRect(i, headY-1, 1, 2);
    ctx.fillRect(1, headY, a.w-2, 2);
    ctx.fillRect(1, headY+1, 2, 5);
    ctx.fillRect(a.w-3, headY+1, 2, 5);

    ctx.fillStyle = hair2;
    ctx.fillRect(2, headY, a.w-4, 1);

    // Eyes
    ctx.fillStyle = "#111";
    ctx.fillRect(4, headY+2, 1, 1);
    ctx.fillRect(a.w-5, headY+2, 1, 1);

    // Flowers + chocolates (tiny icons if sitting)
    if (sitting) {
      // flowers
      ctx.fillStyle = "#8cff6a";
      ctx.fillRect(2, bodyY+1, 2, 2);
      ctx.fillStyle = "#ff5a7a";
      ctx.fillRect(4, bodyY+1, 2, 2);
      ctx.fillStyle = "#ffd36a";
      ctx.fillRect(3, bodyY+3, 2, 1);
      // chocolates
      ctx.fillStyle = "#4a2b1a";
      ctx.fillRect(a.w-5, bodyY+1, 3, 2);
      ctx.fillStyle = "rgba(255,255,255,0.20)";
      ctx.fillRect(a.w-5, bodyY+1, 3, 1);
    }

    // Outline
    ctx.strokeStyle = outline;
    ctx.strokeRect(1, headY, a.w-2, a.h-1);

    ctx.restore();
  }

  // ---------- Scene base ----------
  class Scene {
    constructor(name) { this.name = name; }
    update(dt) {}
    render(ctx) {}
    onMouseDown(e, world, button) {}
    clampCamera() {}
    getColliders() { return []; }
  }

  // ---------- Bedroom Scene ----------
  class BedroomScene extends Scene {
    constructor(player) {
      super("bedroom");
      this.player = player;
      this.world = { w: 420, h: 260 };

      this.bed = { x: 42, y: 56, w: 44, h: 22 };
      this.desk = { x: 245, y: 60, w: 36, h: 16 };
      this.chair = { x: 262, y: 80, w: 12, h: 10 };
      this.dresser = { x: 60, y: 178, w: 30, h: 18 };
      this.closet = { x: 300, y: 170, w: 52, h: 24 };
      this.carpet = { x: 160, y: 120, w: 85, h: 55 };

      this.colliders = [this.bed, this.desk, this.chair, this.dresser, this.closet];

      this.door = { x: this.world.w - 14, y: Math.floor(this.world.h/2) - 18, w: 10, h: 36 };
      this.doorGlow = 0;
      this.doorOpen = false;

      this.posters = [
        { x: 120, y: 20, w: 18, h: 26, c: "#b14cff" },
        { x: 145, y: 22, w: 16, h: 22, c: "#3ad1ff" },
        { x: 180, y: 18, w: 22, h: 30, c: "#ff5a7a" },
        { x: 210, y: 24, w: 16, h: 20, c: "#8cff6a" },
      ];

      // Spawn in bed
      this.player.x = this.bed.x + 12;
      this.player.y = this.bed.y + this.bed.h + 2;
      this.player.canControl = false;
      this.player.target = null;
      this.player.moving = false;
      this.player.pose = "stand";
      this.player.intro.active = true;
      this.player.intro.t = 0;
      this.player.intro.phase = 0;

      statusEl.textContent = " | Kaitlyn wakes up...";
    }

    getColliders() { return this.colliders; }

    update(dt) {
      const p = this.player;

      // Intro: get out of bed
      if (p.intro.active) {
        p.intro.t += dt;
        if (p.intro.phase === 0 && p.intro.t > 0.4) p.intro.phase = 1;
        if (p.intro.phase === 1 && p.intro.t > 0.9) {
          p.intro.phase = 2;
          p.target = { x: p.x + p.w/2, y: p.y + 22 + p.h/2 };
          p.moving = true;
          statusEl.textContent = " | ...getting out of bed.";
        }
        if (p.intro.phase === 2) {
          if (!p.moving) {
            p.intro.phase = 3;
            p.intro.active = false;
            p.canControl = true;
            statusEl.textContent = " | Find the door on the right.";
          }
        }
      }

      // Door glow
      const near = dist(
        p.x + p.w/2, p.y + p.h/2,
        this.door.x + this.door.w/2, this.door.y + this.door.h/2
      ) < 26;
      const targetGlow = near ? 1 : 0;
      this.doorGlow += (targetGlow - this.doorGlow) * clamp(dt * 8, 0, 1);

      // Move player
      this.movePlayer(dt);

      follow(p);
      this.clampCamera();
    }

    clampCamera() {
      camera.x = clamp(camera.x, 0, this.world.w - W);
      camera.y = clamp(camera.y, 0, this.world.h - H);
    }

    movePlayer(dt) {
      const p = this.player;
      if (!p.target || !p.moving) return;

      const tx = p.target.x, ty = p.target.y;
      const cx = p.x + p.w/2, cy = p.y + p.h/2;
      const dx = tx - cx, dy = ty - cy;
      const d = Math.hypot(dx, dy);
      if (d < 2) { p.moving = false; return; }

      const vx = (dx / d) * p.speed;
      const vy = (dy / d) * p.speed;

      let nx = p.x + vx * dt;
      let ny = p.y;

      nx = clamp(nx, 0, this.world.w - p.w);
      const testX = { x: nx, y: ny, w: p.w, h: p.h };
      for (const c of this.getColliders()) {
        if (rectsOverlap(testX, c)) { nx = p.x; break; }
      }

      ny = p.y + vy * dt;
      ny = clamp(ny, 0, this.world.h - p.h);
      const testY = { x: nx, y: ny, w: p.w, h: p.h };
      for (const c of this.getColliders()) {
        if (rectsOverlap(testY, c)) { ny = p.y; break; }
      }

      if (Math.abs(vx) > Math.abs(vy)) p.facing = vx > 0 ? "right" : "left";
      else p.facing = vy > 0 ? "down" : "up";

      p.x = nx; p.y = ny;
    }

    onMouseDown(e, world, button) {
      const p = this.player;

      // Right click: move
      if (button === 2) {
        if (!p.canControl) return;
        const tx = clamp(world.x, 0, this.world.w);
        const ty = clamp(world.y, 0, this.world.h);
        p.target = { x: tx, y: ty };
        p.moving = true;
        return;
      }

      // Left click: door interact
      if (button === 0) {
        const near = dist(
          p.x + p.w/2, p.y + p.h/2,
          this.door.x + this.door.w/2, this.door.y + this.door.h/2
        ) < 26;

        const clickedDoor =
          world.x >= this.door.x - 6 && world.x <= this.door.x + this.door.w + 6 &&
          world.y >= this.door.y - 6 && world.y <= this.door.y + this.door.h + 6;

        if (near && clickedDoor) {
          this.doorOpen = true;
          statusEl.textContent = " | Loading...";
          beginTransitionTo("park");
        }
      }
    }

    render(ctx) {
      // Background
      ctx.fillStyle = "#2a2030";
      ctx.fillRect(0, 0, W, H);

      const rx = -camera.x, ry = -camera.y;

      // Room
      ctx.fillStyle = "#3a2d42";
      ctx.fillRect(rx, ry, this.world.w, this.world.h);

      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.strokeRect(rx + 2, ry + 2, this.world.w - 4, this.world.h - 4);

      // Posters
      for (const p of this.posters) {
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.fillRect(rx + p.x + 1, ry + p.y + 1, p.w, p.h);
        ctx.fillStyle = p.c;
        ctx.fillRect(rx + p.x, ry + p.y, p.w, p.h);
        ctx.fillStyle = "rgba(255,255,255,0.25)";
        ctx.fillRect(rx + p.x + 2, ry + p.y + 2, p.w - 4, 2);
      }

      // Carpet
      ctx.fillStyle = "#5b3b67";
      ctx.fillRect(rx + this.carpet.x, ry + this.carpet.y, this.carpet.w, this.carpet.h);
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.strokeRect(rx + this.carpet.x, ry + this.carpet.y, this.carpet.w, this.carpet.h);

      // Furniture helper
      const drawBox = (o, fill, stroke) => {
        ctx.fillStyle = fill;
        ctx.fillRect(rx + o.x, ry + o.y, o.w, o.h);
        ctx.strokeStyle = stroke || "rgba(0,0,0,0.35)";
        ctx.strokeRect(rx + o.x, ry + o.y, o.w, o.h);
      };

      // Bed
      drawBox(this.bed, "#875a6a");
      ctx.fillStyle = "#e7d9e1"; // pillow
      ctx.fillRect(rx + this.bed.x + 4, ry + this.bed.y + 3, 14, 6);
      ctx.fillStyle = "rgba(0,0,0,0.12)";
      ctx.fillRect(rx + this.bed.x + 2, ry + this.bed.y + 12, this.bed.w - 4, 2);

      // Desk + chair
      drawBox(this.desk, "#7c5c3c");
      drawBox(this.chair, "#6a4d35");
      ctx.fillStyle = "#1b1b22"; // monitor
      ctx.fillRect(rx + this.desk.x + 6, ry + this.desk.y + 2, 10, 6);
      ctx.fillStyle = "rgba(255,255,255,0.10)";
      ctx.fillRect(rx + this.desk.x + 7, ry + this.desk.y + 3, 8, 2);

      // Dresser
      drawBox(this.dresser, "#6a3f2b");
      ctx.fillStyle = "rgba(255,255,255,0.15)";
      ctx.fillRect(rx + this.dresser.x + 4, ry + this.dresser.y + 4, this.dresser.w - 8, 2);
      ctx.fillRect(rx + this.dresser.x + 4, ry + this.dresser.y + 10, this.dresser.w - 8, 2);

      // Closet
      drawBox(this.closet, "#3e4a52");
      ctx.fillStyle = "rgba(255,255,255,0.12)";
      ctx.fillRect(rx + this.closet.x + this.closet.w/2 - 1, ry + this.closet.y + 2, 2, this.closet.h - 4);

      // Door
      const d = this.door;
      ctx.fillStyle = "#1b121f";
      ctx.fillRect(rx + d.x - 2, ry + d.y - 2, d.w + 4, d.h + 4);

      if (this.doorGlow > 0.01) {
        ctx.globalAlpha = 0.25 * this.doorGlow;
        ctx.fillStyle = "#ffd36a";
        ctx.fillRect(rx + d.x - 6, ry + d.y - 6, d.w + 12, d.h + 12);
        ctx.globalAlpha = 1;
        statusEl.textContent = " | Door is glowing... left-click it.";
      }

      ctx.fillStyle = this.doorOpen ? "#101015" : "#2d1d32";
      ctx.fillRect(rx + d.x, ry + d.y, d.w, d.h);
      ctx.fillStyle = "#d1b26a";
      ctx.fillRect(rx + d.x + d.w - 3, ry + d.y + Math.floor(d.h/2), 2, 2);

      // Player
      drawKaitlyn(ctx, { x: rx + this.player.x, y: ry + this.player.y, w: this.player.w, h: this.player.h }, this.player.pose);

      // Target marker
      if (this.player.target && this.player.canControl) {
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = "rgba(255,255,255,0.75)";
        const tx = rx + this.player.target.x;
        const ty = ry + this.player.target.y;
        ctx.fillRect(Math.round(tx) - 1, Math.round(ty) - 1, 2, 2);
        ctx.globalAlpha = 1;
      }
    }
  }

  // ---------- Park Scene with bench + Valentine event ----------
  class ParkScene extends Scene {
    constructor(player) {
      super("park");
      this.player = player;
      this.world = { w: 600, h: 360 };

      // Friendly path
      this.path = [
        { x: 70, y: 300 }, { x: 150, y: 260 }, { x: 230, y: 230 },
        { x: 310, y: 210 }, { x: 400, y: 200 }, { x: 490, y: 180 }, { x: 520, y: 140 }
      ];

      // Pond
      this.pond = { x: 370, y: 250, w: 140, h: 80 };

      // Trees (colliders)
      this.trees = [];
      const treeSpots = [
        [70,70],[120,90],[170,60],[220,85],[260,60],
        [520,60],[560,110],[90,340],[140,320],[200,340],
        [30,210],[560,270],[500,310],[430,80],[470,110]
      ];
      for (const [x,y] of treeSpots) this.trees.push({ x, y, w: 18, h: 18 });

      // Flowers (LOTS)
      this.flowers = [];
      for (let i = 0; i < 380; i++) {
        this.flowers.push({
          x: Math.random() * this.world.w,
          y: Math.random() * this.world.h,
          c: ["#ff5a7a","#ffd36a","#8cff6a","#3ad1ff","#b14cff"][Math.floor(Math.random()*5)],
          s: 1 + Math.floor(Math.random()*2)
        });
      }

      // Birds
      this.birds = [];
      for (let i = 0; i < 9; i++) {
        this.birds.push({
          x: 60 + Math.random()*this.world.w,
          y: 40 + Math.random()*130,
          vx: 10 + Math.random()*22
        });
      }

      // Bench at end of path
      this.bench = { x: 520, y: 120, w: 40, h: 14 };

      // Angel sitting on the bench holding flowers+chocolates
      this.angel = { name:"Angel", x: this.bench.x + 18, y: this.bench.y - 2, w: 10, h: 12 };
      this.angelGlow = 0;

      // Valentine event state machine
      this.event = {
        started: false,
        stage: "idle", // idle -> approachLock -> sitAnim -> question -> choice -> hug -> end
        t: 0,
        yesScale: 1,
        noCount: 0,
        bubble: { show: false, text: "will you be my valentine?" },
      };

      // Spawn player near path start
      this.player.x = 80;
      this.player.y = 300;
      this.player.target = null;
      this.player.moving = false;
      this.player.canControl = true;
      this.player.pose = "stand";

      // Reset UI
      hideChoices();
      endOverlay.style.display = "none";
      statusEl.textContent = " | Follow the path...";
    }

    getColliders() {
      const pondCollider = { x: this.pond.x + 12, y: this.pond.y + 12, w: this.pond.w - 24, h: this.pond.h - 24 };
      // bench acts as collider (so you don't walk through it)
      const benchCollider = { x: this.bench.x, y: this.bench.y, w: this.bench.w, h: this.bench.h };
      return [...this.trees, pondCollider, benchCollider];
    }

    update(dt) {
      // Birds
      for (const b of this.birds) {
        b.x += b.vx * dt;
        if (b.x > this.world.w + 40) b.x = -40;
      }

      // Angel glow when near (unless end)
      const p = this.player;
      const nearAngel = dist(p.x + p.w/2, p.y + p.h/2, this.angel.x + this.angel.w/2, this.angel.y + this.angel.h/2) < 28;
      const targetGlow = (nearAngel && this.event.stage === "idle") ? 1 : 0;
      this.angelGlow += (targetGlow - this.angelGlow) * clamp(dt * 8, 0, 1);

      // Event staged animations
      this.updateEvent(dt);

      // Movement allowed only if canControl
      if (p.canControl) this.movePlayer(dt);

      follow(p);
      this.clampCamera();
    }

    updateEvent(dt) {
      const ev = this.event;
      const p = this.player;

      if (ev.stage === "approachLock" || ev.stage === "sitAnim" || ev.stage === "hug") {
        ev.t += dt;
      }

      // Stage: approachLock -> move Kaitlyn to sit position (auto)
      if (ev.stage === "approachLock") {
        // autopilot to bench sit spot
        const sitSpot = { x: this.bench.x + 8, y: this.bench.y + 3 };
        // set target if not moving
        if (!p.moving) {
          p.target = { x: sitSpot.x + p.w/2, y: sitSpot.y + p.h/2 };
          p.moving = true;
        }
        // once close enough, sit
        const d = dist(p.x, p.y, sitSpot.x, sitSpot.y);
        if (d < 2.5) {
          p.moving = false;
          p.target = null;
          p.pose = "sit";
          ev.stage = "sitAnim";
          ev.t = 0;
        }
      }

      // Stage: sitAnim -> short pause then show question bubble
      if (ev.stage === "sitAnim") {
        if (ev.t > 0.6) {
          ev.stage = "question";
          ev.bubble.show = true;
          showChoices(ev);
          statusEl.textContent = " | ...";
        }
      }

      // Stage: hug -> after a moment show The End
      if (ev.stage === "hug") {
        if (ev.t > 1.0) {
          ev.stage = "end";
          endOverlay.style.display = "flex";
          hideChoices();
          ev.bubble.show = false;
          statusEl.textContent = " | ";
        }
      }
    }

    clampCamera() {
      camera.x = clamp(camera.x, 0, this.world.w - W);
      camera.y = clamp(camera.y, 0, this.world.h - H);
    }

    movePlayer(dt) {
      const p = this.player;
      if (!p.target || !p.moving) return;

      const tx = p.target.x, ty = p.target.y;
      const cx = p.x + p.w/2, cy = p.y + p.h/2;
      const dx = tx - cx, dy = ty - cy;
      const d = Math.hypot(dx, dy);
      if (d < 2) { p.moving = false; return; }

      const vx = (dx / d) * p.speed;
      const vy = (dy / d) * p.speed;

      let nx = p.x + vx * dt;
      let ny = p.y;

      nx = clamp(nx, 0, this.world.w - p.w);
      const testX = { x: nx, y: ny, w: p.w, h: p.h };
      for (const c of this.getColliders()) {
        if (rectsOverlap(testX, c)) { nx = p.x; break; }
      }

      ny = p.y + vy * dt;
      ny = clamp(ny, 0, this.world.h - p.h);
      const testY = { x: nx, y: ny, w: p.w, h: p.h };
      for (const c of this.getColliders()) {
        if (rectsOverlap(testY, c)) { ny = p.y; break; }
      }

      if (Math.abs(vx) > Math.abs(vy)) p.facing = vx > 0 ? "right" : "left";
      else p.facing = vy > 0 ? "down" : "up";

      p.x = nx; p.y = ny;
      p.pose = "stand";
    }

    onMouseDown(e, world, button) {
      const p = this.player;

      // If choices are up, ignore clicks on canvas (keep it clean)
      if (this.event.stage === "question" || this.event.stage === "choice") return;
      if (this.event.stage === "hug" || this.event.stage === "end") return;

      // Right click: move if allowed
      if (button === 2) {
        if (!p.canControl) return;
        const tx = clamp(world.x, 0, this.world.w);
        const ty = clamp(world.y, 0, this.world.h);
        p.target = { x: tx, y: ty };
        p.moving = true;
        return;
      }

      // Left click: interact with Angel if near and glowing
      if (button === 0 && this.event.stage === "idle") {
        const nearAngel = dist(p.x + p.w/2, p.y + p.h/2, this.angel.x + this.angel.w/2, this.angel.y + this.angel.h/2) < 28;

        const clickedAngel =
          world.x >= this.angel.x - 6 && world.x <= this.angel.x + this.angel.w + 6 &&
          world.y >= this.angel.y - 6 && world.y <= this.angel.y + this.angel.h + 6;

        if (nearAngel && clickedAngel) {
          // Lock player, start sit sequence
          p.canControl = false;
          p.target = null;
          p.moving = false;
          this.event.started = true;
          this.event.stage = "approachLock";
          this.event.t = 0;
          statusEl.textContent = " | ";
        }
      }
    }

    render(ctx) {
      // Grass base
      ctx.fillStyle = "#244224";
      ctx.fillRect(0, 0, W, H);

      const rx = -camera.x, ry = -camera.y;

      // World grass
      ctx.fillStyle = "#2d5b2d";
      ctx.fillRect(rx, ry, this.world.w, this.world.h);

      // Flowers
      for (const f of this.flowers) {
        const x = rx + f.x, y = ry + f.y;
        if (x < -5 || y < -5 || x > W+5 || y > H+5) continue;
        ctx.fillStyle = f.c;
        ctx.fillRect(Math.round(x), Math.round(y), f.s, f.s);
        ctx.fillStyle = "rgba(255,255,255,0.25)";
        ctx.fillRect(Math.round(x)+1, Math.round(y), 1, 1);
      }

      // Path
      ctx.strokeStyle = "rgba(245, 230, 195, 0.90)";
      ctx.lineWidth = 6;
      ctx.beginPath();
      for (let i = 0; i < this.path.length; i++) {
        const p = this.path[i];
        const x = rx + p.x, y = ry + p.y;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // Pond
      ctx.fillStyle = "#2c5fa8";
      ctx.beginPath();
      ctx.ellipse(rx + this.pond.x + this.pond.w/2, ry + this.pond.y + this.pond.h/2, this.pond.w/2, this.pond.h/2, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.ellipse(rx + this.pond.x + this.pond.w/2 - 18, ry + this.pond.y + this.pond.h/2 - 12, this.pond.w/2 - 26, this.pond.h/2 - 26, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // Trees
      for (const t of this.trees) {
        ctx.fillStyle = "#5a3c22";
        ctx.fillRect(rx + t.x + 7, ry + t.y + 10, 4, 8);
        ctx.fillStyle = "#163d16";
        ctx.fillRect(rx + t.x, ry + t.y, t.w, t.h);
        ctx.fillStyle = "rgba(255,255,255,0.10)";
        ctx.fillRect(rx + t.x + 2, ry + t.y + 2, t.w - 4, 2);
      }

      // Birds
      ctx.fillStyle = "rgba(255,255,255,0.8)";
      for (const b of this.birds) {
        const x = rx + b.x, y = ry + b.y;
        if (x < -10 || x > W+10) continue;
        ctx.fillRect(Math.round(x), Math.round(y), 2, 1);
        ctx.fillRect(Math.round(x)+3, Math.round(y)+1, 2, 1);
      }

      // Bench
      const bn = this.bench;
      ctx.fillStyle = "#6a4d35";
      ctx.fillRect(rx + bn.x, ry + bn.y, bn.w, bn.h);
      ctx.fillStyle = "rgba(0,0,0,0.18)";
      ctx.fillRect(rx + bn.x, ry + bn.y + 4, bn.w, 2);
      // bench legs
      ctx.fillStyle = "#4f3727";
      ctx.fillRect(rx + bn.x + 4, ry + bn.y + bn.h, 4, 4);
      ctx.fillRect(rx + bn.x + bn.w - 8, ry + bn.y + bn.h, 4, 4);

      // Angel (sitting)
      const angelPose = (this.event.stage === "hug" || this.event.stage === "end") ? "hug" : "sit";
      drawAngel(ctx, { x: rx + this.angel.x, y: ry + this.angel.y, w: this.angel.w, h: this.angel.h }, angelPose, this.angelGlow);

      // Player
      const p = this.player;
      const pPose = (this.event.stage === "hug" || this.event.stage === "end") ? "hug"
                   : (this.event.stage === "question" || this.event.stage === "choice" || this.event.stage === "sitAnim") ? "sit"
                   : p.pose;
      drawKaitlyn(ctx, { x: rx + p.x, y: ry + p.y, w: p.w, h: p.h }, pPose);

      // Target marker
      if (p.target && p.canControl) {
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = "rgba(255,255,255,0.75)";
        const tx = rx + p.target.x;
        const ty = ry + p.target.y;
        ctx.fillRect(Math.round(tx) - 1, Math.round(ty) - 1, 2, 2);
        ctx.globalAlpha = 1;
      }

      // Speech bubble over Angel
      if (this.event.bubble.show) {
        const bx = rx + this.angel.x + this.angel.w/2;
        const by = ry + this.angel.y - 14;

        // Bubble background
        const text = this.event.bubble.text;
        // Very simple text box sizing
        const bw = 150, bh = 20;
        const x = Math.round(bx - bw/2);
        const y = Math.round(by - bh);

        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(x, y, bw, bh);
        ctx.strokeStyle = "rgba(255,255,255,0.18)";
        ctx.strokeRect(x, y, bw, bh);

        // Tail
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(Math.round(bx)-2, y+bh, 4, 4);

        // Text
        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.font = "8px system-ui, Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, x + bw/2, y + bh/2 + 1);
      }

      // Hint status when near Angel (only before interaction)
      if (this.event.stage === "idle" && this.angelGlow > 0.2) {
        statusEl.textContent = " | Angel is glowing... left-click him.";
      }
    }
  }

  // ---------- Transition system ----------
  const player = makePlayer();
  let scene = new BedroomScene(player);

  const transition = { active:false, t:0, dir:1, nextScene:null };

  function beginTransitionTo(name) {
    if (transition.active) return;
    transition.active = true;
    transition.t = 0;
    transition.dir = 1;
    transition.nextScene = name;
  }

  function doTransition(dt) {
    if (!transition.active) return;
    transition.t += dt * 1.2;
    if (transition.dir === 1 && transition.t >= 1) {
      transition.t = 1;
      if (transition.nextScene === "park") scene = new ParkScene(player);
      transition.dir = -1;
    } else if (transition.dir === -1 && transition.t <= 0) {
      transition.t = 0;
      transition.active = false;
    }
  }

  // ---------- Dialogue UI logic ----------
  function showChoices(ev) {
    dialogueUI.style.display = "block";
    midMsg.style.display = "none";
    ev.stage = "choice";
    ev.yesScale = 1;
    ev.noCount = 0;
    applyYesSize(ev.yesScale);

    // Important: player stays locked
    player.canControl = false;
    player.moving = false;
    player.target = null;
  }

  function hideChoices() {
    dialogueUI.style.display = "none";
    midMsg.style.display = "none";
  }

  function applyYesSize(scale) {
    // Scale by padding and font-size so it gets comically unavoidable
    const basePadX = 16, basePadY = 10;
    const padX = Math.round(basePadX * scale);
    const padY = Math.round(basePadY * scale);
    const font = Math.round(14 * scale);

    yesBtn.style.padding = `${padY}px ${padX}px`;
    yesBtn.style.fontSize = `${font}px`;
  }

  // Hook up choice buttons once (they act on the current scene if it's park)
  yesBtn.addEventListener("click", () => {
    if (!(scene instanceof ParkScene)) return;
    const ev = scene.event;

    // Only valid during choice
    if (ev.stage !== "choice") return;

    // Hug on bench + end
    ev.stage = "hug";
    ev.t = 0;
    ev.bubble.show = false;

    // Visual: set poses
    player.pose = "hug";

    // Stop UI
    hideChoices();
  });

  noBtn.addEventListener("click", () => {
    if (!(scene instanceof ParkScene)) return;
    const ev = scene.event;
    if (ev.stage !== "choice") return;

    // "try again" + yes gets bigger
    ev.noCount += 1;
    midMsg.style.display = "inline-flex";

    // Growth curve: quickly becomes silly
    ev.yesScale = 1 + ev.noCount * 0.18;
    applyYesSize(ev.yesScale);

    // If it gets too massive, gently nudge layout
    if (ev.yesScale >= 2.2) {
      midMsg.textContent = "try again ðŸ™‚";
    } else {
      midMsg.textContent = "try again.";
    }
  });

  // ---------- Input ----------
  canvas.addEventListener("mousedown", (e) => {
    const local = screenToWorld(e);
    const world = { x: local.x + camera.x, y: local.y + camera.y };
    scene.onMouseDown(e, world, e.button);
  });

  // ---------- Main loop ----------
  let last = performance.now();
  function tick(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    scene.update(dt);
    doTransition(dt);

    // Render to offscreen
    octx.clearRect(0, 0, W, H);
    scene.render(octx);

    // Fade overlay
    if (transition.active) {
      octx.save();
      octx.globalAlpha = transition.t;
      octx.fillStyle = "#000";
      octx.fillRect(0, 0, W, H);
      octx.restore();
    }

    // Draw scaled to visible canvas
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(off, 0, 0, canvas.width, canvas.height);

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

})();
</script>
</body>
</html>

